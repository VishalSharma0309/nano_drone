<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>File-System</title>
<title>Runtime: File-System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pulp.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="printComponentTabs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 46px;">
  <td id="projectlogo"><img alt="Logo" src="Pulp_logo_inline.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Runtime
   &#160;<span id="projectnumber">Version 1.0</span>
   </div>
   <div id="projectbrief">PULP Kernel Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
    <ul class="tablist">
      <script type="text/javascript">
		<!--
		writeComponentTabs.call(this);
		//-->
      </script>
	  </ul>
</div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__FS.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">File-System<div class="ingroups"><a class="el" href="group__groupDrivers.html">Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrt__fs__conf__t.html">rt_fs_conf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">File-system configuration structure.  <a href="structrt__fs__conf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga7d7ae1c74fb27276549dc977de60acb4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga7d7ae1c74fb27276549dc977de60acb4">rt_fs_error_e</a> <tr class="memdesc:ga7d7ae1c74fb27276549dc977de60acb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">File-system errors.  <a href="group__FS.html#ga7d7ae1c74fb27276549dc977de60acb4">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga7d7ae1c74fb27276549dc977de60acb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf573435a1c8ebedb3a7e4fbe575309c2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#gaf573435a1c8ebedb3a7e4fbe575309c2">rt_fs_type_e</a> <tr class="memdesc:gaf573435a1c8ebedb3a7e4fbe575309c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">File-system type.  <a href="group__FS.html#gaf573435a1c8ebedb3a7e4fbe575309c2">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gaf573435a1c8ebedb3a7e4fbe575309c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0e81ac64ef81d69ff06ff4eeb53fe752"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga0e81ac64ef81d69ff06ff4eeb53fe752">rt_fs_conf_init</a> (<a class="el" href="structrt__fs__conf__t.html">rt_fs_conf_t</a> *conf)</td></tr>
<tr class="memdesc:ga0e81ac64ef81d69ff06ff4eeb53fe752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a file-system configuration with default values.  <a href="#ga0e81ac64ef81d69ff06ff4eeb53fe752">More...</a><br /></td></tr>
<tr class="separator:ga0e81ac64ef81d69ff06ff4eeb53fe752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33f57ab1ca7c56fb2f7135d6c75a969f"><td class="memItemLeft" align="right" valign="top">rt_fs_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga33f57ab1ca7c56fb2f7135d6c75a969f">rt_fs_mount</a> (const char *dev_name, <a class="el" href="structrt__fs__conf__t.html">rt_fs_conf_t</a> *conf, <a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *event)</td></tr>
<tr class="memdesc:ga33f57ab1ca7c56fb2f7135d6c75a969f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mount a file-system.  <a href="#ga33f57ab1ca7c56fb2f7135d6c75a969f">More...</a><br /></td></tr>
<tr class="separator:ga33f57ab1ca7c56fb2f7135d6c75a969f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga274ea61e8bfad15c1fbe4fe208d2d343"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga274ea61e8bfad15c1fbe4fe208d2d343">rt_fs_unmount</a> (rt_fs_t *handle, <a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *event)</td></tr>
<tr class="memdesc:ga274ea61e8bfad15c1fbe4fe208d2d343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmount a mounted file-system.  <a href="#ga274ea61e8bfad15c1fbe4fe208d2d343">More...</a><br /></td></tr>
<tr class="separator:ga274ea61e8bfad15c1fbe4fe208d2d343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1809ef36e97a136b4addcdc0ea79cd2b"><td class="memItemLeft" align="right" valign="top">rt_file_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga1809ef36e97a136b4addcdc0ea79cd2b">rt_fs_open</a> (rt_fs_t *fs, const char *file, int flags, <a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *event)</td></tr>
<tr class="memdesc:ga1809ef36e97a136b4addcdc0ea79cd2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file.  <a href="#ga1809ef36e97a136b4addcdc0ea79cd2b">More...</a><br /></td></tr>
<tr class="separator:ga1809ef36e97a136b4addcdc0ea79cd2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga227eed5ad1de2c6b7c6ab382b57e16fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga227eed5ad1de2c6b7c6ab382b57e16fb">rt_fs_close</a> (rt_file_t *file, <a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *event)</td></tr>
<tr class="memdesc:ga227eed5ad1de2c6b7c6ab382b57e16fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a file.  <a href="#ga227eed5ad1de2c6b7c6ab382b57e16fb">More...</a><br /></td></tr>
<tr class="separator:ga227eed5ad1de2c6b7c6ab382b57e16fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad8f93c4960a93120f951526959fce61"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#gaad8f93c4960a93120f951526959fce61">rt_fs_read</a> (rt_file_t *file, void *buffer, size_t size, <a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *event)</td></tr>
<tr class="memdesc:gaad8f93c4960a93120f951526959fce61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a file.  <a href="#gaad8f93c4960a93120f951526959fce61">More...</a><br /></td></tr>
<tr class="separator:gaad8f93c4960a93120f951526959fce61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de842485c6bee954d5f8ea778a99e55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga2de842485c6bee954d5f8ea778a99e55">rt_fs_direct_read</a> (rt_file_t *file, void *buffer, size_t size, <a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *event)</td></tr>
<tr class="memdesc:ga2de842485c6bee954d5f8ea778a99e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a file with no intermediate cache.  <a href="#ga2de842485c6bee954d5f8ea778a99e55">More...</a><br /></td></tr>
<tr class="separator:ga2de842485c6bee954d5f8ea778a99e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84b167ae4b481c93b91d7bcd9351b999"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga84b167ae4b481c93b91d7bcd9351b999">rt_fs_seek</a> (rt_file_t *file, unsigned int offset)</td></tr>
<tr class="memdesc:ga84b167ae4b481c93b91d7bcd9351b999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reposition the current file position.  <a href="#ga84b167ae4b481c93b91d7bcd9351b999">More...</a><br /></td></tr>
<tr class="separator:ga84b167ae4b481c93b91d7bcd9351b999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f504e998b5ef626468a041793493373"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga0f504e998b5ef626468a041793493373">rt_fs_cluster_read</a> (rt_file_t *file, void *buffer, size_t size, rt_fs_req_t *req)</td></tr>
<tr class="memdesc:ga0f504e998b5ef626468a041793493373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a file from cluster side.  <a href="#ga0f504e998b5ef626468a041793493373">More...</a><br /></td></tr>
<tr class="separator:ga0f504e998b5ef626468a041793493373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacef51e8865439d834d28a3981754730b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#gacef51e8865439d834d28a3981754730b">rt_fs_cluster_direct_read</a> (rt_file_t *file, void *buffer, size_t size, rt_fs_req_t *req)</td></tr>
<tr class="memdesc:gacef51e8865439d834d28a3981754730b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a file with no intermediate cache from cluster side.  <a href="#gacef51e8865439d834d28a3981754730b">More...</a><br /></td></tr>
<tr class="separator:gacef51e8865439d834d28a3981754730b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c84f3d2574d8a6585bef24004b67de8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga4c84f3d2574d8a6585bef24004b67de8">rt_fs_cluster_seek</a> (rt_file_t *file, unsigned int offset, rt_fs_req_t *req)</td></tr>
<tr class="memdesc:ga4c84f3d2574d8a6585bef24004b67de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reposition the current file position from cluster side.  <a href="#ga4c84f3d2574d8a6585bef24004b67de8">More...</a><br /></td></tr>
<tr class="separator:ga4c84f3d2574d8a6585bef24004b67de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga974a74492b21473607b479b380037e4e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FS.html#ga974a74492b21473607b479b380037e4e">rt_fs_cluster_wait</a> (rt_fs_req_t *req)</td></tr>
<tr class="memdesc:ga974a74492b21473607b479b380037e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the specified fs request has finished.  <a href="#ga974a74492b21473607b479b380037e4e">More...</a><br /></td></tr>
<tr class="separator:ga974a74492b21473607b479b380037e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>The file-system driver provides support for accessing files on a flash. The following file-systems are available:</p><ul>
<li>Read-only file system. This file-system is very basic but quite-convenient to have access to input data. The open operation does not scale well when having lots of file so this file-system should only be used with few files. </li>
</ul>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga7d7ae1c74fb27276549dc977de60acb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d7ae1c74fb27276549dc977de60acb4">&#9670;&nbsp;</a></span>rt_fs_error_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__FS.html#ga7d7ae1c74fb27276549dc977de60acb4">rt_fs_error_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is used to report errors related to file-system operations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7d7ae1c74fb27276549dc977de60acb4aab28d044257f78e545d6ea722fba7974"></a>RT_FS_MOUNT_FLASH_ERROR&#160;</td><td class="fielddoc"><p>There was an error mounting the flash filesystem. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7d7ae1c74fb27276549dc977de60acb4aa60649161708a58e541499ccbbfe8d94"></a>RT_FS_MOUNT_MEM_ERROR&#160;</td><td class="fielddoc"><p>There was an error allocating memory when mounting the file-system. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf573435a1c8ebedb3a7e4fbe575309c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf573435a1c8ebedb3a7e4fbe575309c2">&#9670;&nbsp;</a></span>rt_fs_type_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__FS.html#gaf573435a1c8ebedb3a7e4fbe575309c2">rt_fs_type_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This can be used to select the type of file-system to mount. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf573435a1c8ebedb3a7e4fbe575309c2ac7fa63dab15d45965a080959eff2d747"></a>RT_FS_READ_ONLY&#160;</td><td class="fielddoc"><p>Read-only file system. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga227eed5ad1de2c6b7c6ab382b57e16fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga227eed5ad1de2c6b7c6ab382b57e16fb">&#9670;&nbsp;</a></span>rt_fs_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_fs_close </td>
          <td>(</td>
          <td class="paramtype">rt_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to close an opened file once it is not needed anymore in order to free the allocated resources. This operation is asynchronous and its termination can be managed through an event. This can only be called on the fabric-controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The handle of the file to be closed. </td></tr>
    <tr><td class="paramname">event</td><td>The event used for managing termination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacef51e8865439d834d28a3981754730b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacef51e8865439d834d28a3981754730b">&#9670;&nbsp;</a></span>rt_fs_cluster_direct_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rt_fs_cluster_direct_read </td>
          <td>(</td>
          <td class="paramtype">rt_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_fs_req_t *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function implements the same feature as rt_fs_direct_read but can be called from cluster side in order to expose the feature on the cluster. This function can be called to read data from an opened file. The data is read from the current position which is the beginning of the file when the file is opened. The current position is incremented by the number of bytes read by the call to this function. This operation is asynchronous and its termination can be managed through an event. Can only be called from cluster side. Compared to rt_fs_direct_read, this function does direct read transfers from the flash. So the flash address and the size of the transfer can have some constraints depending on the flash.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The handle of the file where to read data. </td></tr>
    <tr><td class="paramname">buffer</td><td>The memory location where the read data must be copied. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes to read from the file. </td></tr>
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f504e998b5ef626468a041793493373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f504e998b5ef626468a041793493373">&#9670;&nbsp;</a></span>rt_fs_cluster_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rt_fs_cluster_read </td>
          <td>(</td>
          <td class="paramtype">rt_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_fs_req_t *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function implements the same feature as rt_fs_read but can be called from cluster side in order to expose the feature on the cluster. This function can be called to read data from an opened file. The data is read from the current position which is the beginning of the file when the file is opened. The current position is incremented by the number of bytes read by the call to this function. This operation is asynchronous and its termination is managed through the request structure. This can only be called on the cluster. Compared to rt_fs_direct_read, this functions can use intermediate transfers to support any alignment constraint from the flash. So it can be slower in case part of the transfer has to be emulated. The only difference compared to rt_fs_read is that the file position is automatically set to 0 for the next transfer if the current transfer reaches the end of the file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The handle of the file where to read data. </td></tr>
    <tr><td class="paramname">buffer</td><td>The memory location where the read data must be copied. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes to read from the file. </td></tr>
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4c84f3d2574d8a6585bef24004b67de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c84f3d2574d8a6585bef24004b67de8">&#9670;&nbsp;</a></span>rt_fs_cluster_seek()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rt_fs_cluster_seek </td>
          <td>(</td>
          <td class="paramtype">rt_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_fs_req_t *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function can be called from cluster side to change the current position of a file. Note that this does not affect pending copies, but only the ones which will be enqueued after this call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The handle of the file for which the current position is changed. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset where to set the current position. The offset can be between 0 for the beginning of the file and the file size. </td></tr>
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga974a74492b21473607b479b380037e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga974a74492b21473607b479b380037e4e">&#9670;&nbsp;</a></span>rt_fs_cluster_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rt_fs_cluster_wait </td>
          <td>(</td>
          <td class="paramtype">rt_fs_req_t *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This blocks the calling core until the specified cluster remote copy is finished. As the remote copy is asynchronous, this also gives the number of bytes which was read. Can only be called from cluster side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually read from the file. This can be smaller than the requested size if the end of file is reached. Could be also RT_STATUS_OK if the rt_fs_cluster_seek was successful, RT_STATUS_ERR otherwise. </dd></dl>

</div>
</div>
<a id="ga0e81ac64ef81d69ff06ff4eeb53fe752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e81ac64ef81d69ff06ff4eeb53fe752">&#9670;&nbsp;</a></span>rt_fs_conf_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_fs_conf_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__fs__conf__t.html">rt_fs_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The structure containing the configuration must be kept allocated until the file-system is mounted. This can only be called on the fabric-controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>A pointer to the file-system configuration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2de842485c6bee954d5f8ea778a99e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2de842485c6bee954d5f8ea778a99e55">&#9670;&nbsp;</a></span>rt_fs_direct_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_fs_direct_read </td>
          <td>(</td>
          <td class="paramtype">rt_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to read data from an opened file. The data is read from the current position which is the beginning of the file when the file is opened. The current position is incremented by the number of bytes read by the call to this function. This operation is asynchronous and its termination can be managed through an event. This can only be called on the fabric-controller. Compared to rt_fs_read, this function does direct read transfers from the flash. So the flash address and the size of the transfer can have some constraints depending on the flash.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The handle of the file where to read data. </td></tr>
    <tr><td class="paramname">buffer</td><td>The memory location where the read data must be copied. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes to read from the file. </td></tr>
    <tr><td class="paramname">event</td><td>The event used for managing termination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually read from the file. This can be smaller than the requested size if the end of file is reached. </dd></dl>

</div>
</div>
<a id="ga33f57ab1ca7c56fb2f7135d6c75a969f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33f57ab1ca7c56fb2f7135d6c75a969f">&#9670;&nbsp;</a></span>rt_fs_mount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_fs_t* rt_fs_mount </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dev_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrt__fs__conf__t.html">rt_fs_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function must be called before the file-system is used. It will do all necessary configuration and return a handle used to refer to this file-system when calling other functions. This operation is asynchronous and its termination can be managed through an event. This can only be called on the fabric-controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_name</td><td>The device name where the file-system must be mounted. This name should correspond to the one used to configure the devices managed by the runtime. The data pointed by this pointer variable must be kept valid until the file-system is mounted. </td></tr>
    <tr><td class="paramname">conf</td><td>A pointer to the file-system configuration. Can be NULL to take default configuration. </td></tr>
    <tr><td class="paramname">event</td><td>The event used for managing termination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the device is not found, or a handle identifying the file-system and which can be used with other functions. </dd></dl>

</div>
</div>
<a id="ga1809ef36e97a136b4addcdc0ea79cd2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1809ef36e97a136b4addcdc0ea79cd2b">&#9670;&nbsp;</a></span>rt_fs_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rt_file_t* rt_fs_open </td>
          <td>(</td>
          <td class="paramtype">rt_fs_t *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to open a file on a file-system in order to read or write data to it. This operation is asynchronous and its termination can be managed through an event. This can only be called on the fabric-controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>The handle of the file-system which was returned when the file-system was mounted. </td></tr>
    <tr><td class="paramname">file</td><td>The path to the file to be opened. </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags to configure how the file is opened. </td></tr>
    <tr><td class="paramname">event</td><td>The event used for managing termination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the file is not found, or a handle identifying the file which can be used with other functions. </dd></dl>

</div>
</div>
<a id="gaad8f93c4960a93120f951526959fce61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad8f93c4960a93120f951526959fce61">&#9670;&nbsp;</a></span>rt_fs_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_fs_read </td>
          <td>(</td>
          <td class="paramtype">rt_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to read data from an opened file. The data is read from the current position which is the beginning of the file when the file is opened. The current position is incremented by the number of bytes read by the call to this function. This operation is asynchronous and its termination can be managed through an event. This can only be called on the fabric-controller. Compared to rt_fs_direct_read, this functions can use intermediate transfers to support any alignment constraint from the flash. So it can be slower in case part of the transfer has to be emulated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The handle of the file where to read data. </td></tr>
    <tr><td class="paramname">buffer</td><td>The memory location where the read data must be copied. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes to read from the file. </td></tr>
    <tr><td class="paramname">event</td><td>The event used for managing termination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually read from the file. This can be smaller than the requested size if the end of file is reached. </dd></dl>

</div>
</div>
<a id="ga84b167ae4b481c93b91d7bcd9351b999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84b167ae4b481c93b91d7bcd9351b999">&#9670;&nbsp;</a></span>rt_fs_seek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_fs_seek </td>
          <td>(</td>
          <td class="paramtype">rt_file_t *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to change the current position of a file. Note that this does not affect pending copies, but only the ones which will be enqueued after this call. This can only be called on the fabric-controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The handle of the file for which the current position is changed. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset where to set the current position. The offset can be between 0 for the beginning of the file and the file size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RT_STATUS_OK if the operation was successful, RT_STATUS_ERR otherwise. </dd></dl>

</div>
</div>
<a id="ga274ea61e8bfad15c1fbe4fe208d2d343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga274ea61e8bfad15c1fbe4fe208d2d343">&#9670;&nbsp;</a></span>rt_fs_unmount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_fs_unmount </td>
          <td>(</td>
          <td class="paramtype">rt_fs_t *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to close a mounted file-system once it is not needed anymore, in order to free all allocated resources. Once this function is called, the file-system is not accessible anymore and must be mounted again before being used. This operation is asynchronous and its termination can be managed through an event. This can only be called on the fabric-controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle of the file-system which was returned when the file-system was mounted. </td></tr>
    <tr><td class="paramname">event</td><td>The event used for managing termination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
	<!--
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 
	-->
	</li>
  </ul>
</div>
</body>
</html>
