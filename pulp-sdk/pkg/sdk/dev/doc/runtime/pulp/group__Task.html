<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Cluster task scheduler</title>
<title>Runtime: Cluster task scheduler</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pulp.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="printComponentTabs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 46px;">
  <td id="projectlogo"><img alt="Logo" src="Pulp_logo_inline.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Runtime
   &#160;<span id="projectnumber">Version 1.0</span>
   </div>
   <div id="projectbrief">PULP Kernel Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
    <ul class="tablist">
      <script type="text/javascript">
		<!--
		writeComponentTabs.call(this);
		//-->
      </script>
	  </ul>
</div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__Task.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Cluster task scheduler<div class="ingroups"><a class="el" href="group__groupCluster.html">Cluster</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrt__task__conf__t.html">rt_task_conf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task scheduler configuration structure.  <a href="structrt__task__conf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga209dbaf48dfb0279483510083d85a02b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Task.html#ga209dbaf48dfb0279483510083d85a02b">rt_task_conf_init</a> (<a class="el" href="structrt__task__conf__t.html">rt_task_conf_t</a> *conf)</td></tr>
<tr class="memdesc:ga209dbaf48dfb0279483510083d85a02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a task scheduler configuration with default values.  <a href="#ga209dbaf48dfb0279483510083d85a02b">More...</a><br /></td></tr>
<tr class="separator:ga209dbaf48dfb0279483510083d85a02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bf40913c63fd0322bc23ec77cff8532"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Task.html#ga2bf40913c63fd0322bc23ec77cff8532">rt_task_cluster_init</a> (rt_task_cluster_t *cluster, <a class="el" href="structrt__task__conf__t.html">rt_task_conf_t</a> *conf, <a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *event)</td></tr>
<tr class="memdesc:ga2bf40913c63fd0322bc23ec77cff8532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a cluster task scheduler.  <a href="#ga2bf40913c63fd0322bc23ec77cff8532">More...</a><br /></td></tr>
<tr class="separator:ga2bf40913c63fd0322bc23ec77cff8532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2960c4610184f078cb5b3c16eb12028"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Task.html#gaa2960c4610184f078cb5b3c16eb12028">rt_task_cluster_deinit</a> (rt_task_cluster_t *cluster, <a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *event)</td></tr>
<tr class="memdesc:gaa2960c4610184f078cb5b3c16eb12028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a cluster task scheduler.  <a href="#gaa2960c4610184f078cb5b3c16eb12028">More...</a><br /></td></tr>
<tr class="separator:gaa2960c4610184f078cb5b3c16eb12028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ee7fd6dcc4721d4fa274281c3408d44"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Task.html#ga9ee7fd6dcc4721d4fa274281c3408d44">rt_task_init</a> (rt_task_t *task, void(*entry)(rt_task_t *task, int id))</td></tr>
<tr class="memdesc:ga9ee7fd6dcc4721d4fa274281c3408d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a task.  <a href="#ga9ee7fd6dcc4721d4fa274281c3408d44">More...</a><br /></td></tr>
<tr class="separator:ga9ee7fd6dcc4721d4fa274281c3408d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1f9cb50693cbe4032d8c0fb7381f59a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Task.html#gad1f9cb50693cbe4032d8c0fb7381f59a">rt_task_cores</a> (rt_task_t *task, int nb_cores)</td></tr>
<tr class="memdesc:gad1f9cb50693cbe4032d8c0fb7381f59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of cores of a task.  <a href="#gad1f9cb50693cbe4032d8c0fb7381f59a">More...</a><br /></td></tr>
<tr class="separator:gad1f9cb50693cbe4032d8c0fb7381f59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffe001067623b0671f29984c86f2e557"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Task.html#gaffe001067623b0671f29984c86f2e557">rt_task_stacks</a> (rt_task_t *task, void *stacks, int size)</td></tr>
<tr class="memdesc:gaffe001067623b0671f29984c86f2e557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stacks of a task.  <a href="#gaffe001067623b0671f29984c86f2e557">More...</a><br /></td></tr>
<tr class="separator:gaffe001067623b0671f29984c86f2e557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa700d06ea582898fc6d295a81101e1df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Task.html#gaa700d06ea582898fc6d295a81101e1df">rt_task_fc_push</a> (rt_task_cluster_t *cluster, rt_task_t *task, <a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *event)</td></tr>
<tr class="memdesc:gaa700d06ea582898fc6d295a81101e1df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a task from fabric controller side.  <a href="#gaa700d06ea582898fc6d295a81101e1df">More...</a><br /></td></tr>
<tr class="separator:gaa700d06ea582898fc6d295a81101e1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8a7cd2dbe8999be27b2a60bf03d4ad0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Task.html#gaa8a7cd2dbe8999be27b2a60bf03d4ad0">rt_task_cl_push</a> (rt_task_t *task)</td></tr>
<tr class="memdesc:gaa8a7cd2dbe8999be27b2a60bf03d4ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a task from cluster side.  <a href="#gaa8a7cd2dbe8999be27b2a60bf03d4ad0">More...</a><br /></td></tr>
<tr class="separator:gaa8a7cd2dbe8999be27b2a60bf03d4ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3350ddbae1fac7879ae41c959d0b627e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Task.html#ga3350ddbae1fac7879ae41c959d0b627e">rt_task_cl_wait</a> (rt_task_t *task)</td></tr>
<tr class="memdesc:ga3350ddbae1fac7879ae41c959d0b627e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a task completion.  <a href="#ga3350ddbae1fac7879ae41c959d0b627e">More...</a><br /></td></tr>
<tr class="separator:ga3350ddbae1fac7879ae41c959d0b627e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>The cluster task scheduler is an alternative to the default fork/join execution model used on the cluster side. It can be used when the cluster code can be better parallelized using task pipelining rather than the fork/join pattern. It provides the following features:</p><ul>
<li>A task is a structure which contains an entry point and arguments and can be pushed to cluster side for execution.</li>
<li>Once popped by a core, it will be executed until completion, and the core can then proceed with another task.</li>
<li>Tasks are popped by cluster cores in parallel.</li>
<li>Tasks can be pushed to the cluster from either the fabric contoroller or the cluster.</li>
<li>A task can be multicore. Several cores will pop it and will get assigned a different ID.</li>
<li>Tasks can be assigned default global stacks or assigned specific stacks.</li>
<li>Task termination for tasks pushed from fabric controller is managed through the usual event mechanism, and through explicit wait for tasks pushed from cluster side. </li>
</ul>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa8a7cd2dbe8999be27b2a60bf03d4ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8a7cd2dbe8999be27b2a60bf03d4ad0">&#9670;&nbsp;</a></span>rt_task_cl_push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_task_cl_push </td>
          <td>(</td>
          <td class="paramtype">rt_task_t *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to push a task for execution from cluster side. The task is pushed to the cluster from which this function is called. Once this function is called, the task must not be modified anymore. This function must be called only from cluster side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>A pointer to the task structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3350ddbae1fac7879ae41c959d0b627e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3350ddbae1fac7879ae41c959d0b627e">&#9670;&nbsp;</a></span>rt_task_cl_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_task_cl_wait </td>
          <td>(</td>
          <td class="paramtype">rt_task_t *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to block execution until the specified task is over. This can be called only for tasks which has been pushed through rt_task_cl_push. This function must be called only from cluster side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>A pointer to the task structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa2960c4610184f078cb5b3c16eb12028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2960c4610184f078cb5b3c16eb12028">&#9670;&nbsp;</a></span>rt_task_cluster_deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_task_cluster_deinit </td>
          <td>(</td>
          <td class="paramtype">rt_task_cluster_t *&#160;</td>
          <td class="paramname"><em>cluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to close a cluster task scheduler and free all allocated resources. Once it is called, the cluster can be used again with the default fork/join execution model. This function must be called only once no task is executing or ready to be executed in the scheduler. This function can only be called from fabric controller side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cluster</td><td>A pointer to the cluster structure. This structure can be freed once this call is over. </td></tr>
    <tr><td class="paramname">event</td><td>The event used for managing termination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2bf40913c63fd0322bc23ec77cff8532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bf40913c63fd0322bc23ec77cff8532">&#9670;&nbsp;</a></span>rt_task_cluster_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_cluster_init </td>
          <td>(</td>
          <td class="paramtype">rt_task_cluster_t *&#160;</td>
          <td class="paramname"><em>cluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrt__task__conf__t.html">rt_task_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to setup the specified cluster so that it is ready to execute tasks. This function can only be called from fabric controller side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cluster</td><td>A pointer to the cluster structure. This structure must be kept alive until the task scheduler is closed. </td></tr>
    <tr><td class="paramname">conf</td><td>A pointer to the task scheduler configuration. </td></tr>
    <tr><td class="paramname">event</td><td>The event used for managing termination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, or -1 if it failed. </dd></dl>

</div>
</div>
<a id="ga209dbaf48dfb0279483510083d85a02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga209dbaf48dfb0279483510083d85a02b">&#9670;&nbsp;</a></span>rt_task_conf_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_task_conf_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__task__conf__t.html">rt_task_conf_t</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to get default values for all parameters before setting some of them. The structure containing the configuration must be kept alive until the task scheduler is opened. Calling this function will make sure that the task scheduler is created for all cores on cluster 0, with allocated stacks of 512 bytes per core.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>A pointer to the task scheduler configuration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad1f9cb50693cbe4032d8c0fb7381f59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1f9cb50693cbe4032d8c0fb7381f59a">&#9670;&nbsp;</a></span>rt_task_cores()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rt_task_cores </td>
          <td>(</td>
          <td class="paramtype">rt_task_t *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_cores</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function can be called to set the number of cores which will execute the task. The task will remain in the queue until the specified number of cores has popped the queue and each core will get a different task ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>A pointer to the task structure. </td></tr>
    <tr><td class="paramname">nb_cores</td><td>Number of cores </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa700d06ea582898fc6d295a81101e1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa700d06ea582898fc6d295a81101e1df">&#9670;&nbsp;</a></span>rt_task_fc_push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_task_fc_push </td>
          <td>(</td>
          <td class="paramtype">rt_task_cluster_t *&#160;</td>
          <td class="paramname"><em>cluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_task_t *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to push a task for execution from fabric controller side. Once this function is called, the task must not be modified anymore. This function must be called only from fabric controller side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cluster</td><td>A pointer to the cluster structure of the cluster where the task must be pushed. </td></tr>
    <tr><td class="paramname">task</td><td>A pointer to the task structure. </td></tr>
    <tr><td class="paramname">event</td><td>The event used for managing termination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9ee7fd6dcc4721d4fa274281c3408d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ee7fd6dcc4721d4fa274281c3408d44">&#9670;&nbsp;</a></span>rt_task_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rt_task_init </td>
          <td>(</td>
          <td class="paramtype">rt_task_t *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(rt_task_t *task, int id)&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function must be called before a task is pushed to initialize it. This is the only mandatory function to be called on a task before it is pushed. If no more function is called on the task, the task is configured as a single core task with no specific stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>A pointer to the task structure. This structure must be kept alive until the task has finished execution. </td></tr>
    <tr><td class="paramname">entry</td><td>The task entry point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaffe001067623b0671f29984c86f2e557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffe001067623b0671f29984c86f2e557">&#9670;&nbsp;</a></span>rt_task_stacks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rt_task_stacks </td>
          <td>(</td>
          <td class="paramtype">rt_task_t *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stacks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function can be called to set the stacks that the cores will use to execute the task. This must contain one stack for each core which will execute the task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>A pointer to the task structure. </td></tr>
    <tr><td class="paramname">stacks</td><td>The lowest address of the area containing the stacks for all cores. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the stack of one core. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
	<!--
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 
	-->
	</li>
  </ul>
</div>
</body>
</html>
