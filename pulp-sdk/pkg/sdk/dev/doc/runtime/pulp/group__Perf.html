<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Performance counters</title>
<title>Runtime: Performance counters</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pulp.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="printComponentTabs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 46px;">
  <td id="projectlogo"><img alt="Logo" src="Pulp_logo_inline.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Runtime
   &#160;<span id="projectnumber">Version 1.0</span>
   </div>
   <div id="projectbrief">PULP Kernel Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
    <ul class="tablist">
      <script type="text/javascript">
		<!--
		writeComponentTabs.call(this);
		//-->
      </script>
	  </ul>
</div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__Perf.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Performance counters<div class="ingroups"><a class="el" href="group__groupCluster.html">Cluster</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gac08707c4e7d4bbab84241487aa11723b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Perf.html#gac08707c4e7d4bbab84241487aa11723b">rt_perf_event_e</a> <tr class="memdesc:gac08707c4e7d4bbab84241487aa11723b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performance event identifiers.  <a href="group__Perf.html#gac08707c4e7d4bbab84241487aa11723b">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gac08707c4e7d4bbab84241487aa11723b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf013daf2ab420189ad6ab19fa9cd73f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Perf.html#gaf013daf2ab420189ad6ab19fa9cd73f0">rt_perf_init</a> (rt_perf_t *perf)</td></tr>
<tr class="memdesc:gaf013daf2ab420189ad6ab19fa9cd73f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize performance counters structure.  <a href="#gaf013daf2ab420189ad6ab19fa9cd73f0">More...</a><br /></td></tr>
<tr class="separator:gaf013daf2ab420189ad6ab19fa9cd73f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace8fce89c8fd3a8fd96660ad4d7d1853"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Perf.html#gace8fce89c8fd3a8fd96660ad4d7d1853">rt_perf_conf</a> (rt_perf_t *perf, unsigned events)</td></tr>
<tr class="memdesc:gace8fce89c8fd3a8fd96660ad4d7d1853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure performance counters.  <a href="#gace8fce89c8fd3a8fd96660ad4d7d1853">More...</a><br /></td></tr>
<tr class="separator:gace8fce89c8fd3a8fd96660ad4d7d1853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae92c46fde4989dc8b7cd04627e450e58"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Perf.html#gae92c46fde4989dc8b7cd04627e450e58">rt_perf_reset</a> (rt_perf_t *perf)</td></tr>
<tr class="memdesc:gae92c46fde4989dc8b7cd04627e450e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all hardware performance counters.  <a href="#gae92c46fde4989dc8b7cd04627e450e58">More...</a><br /></td></tr>
<tr class="separator:gae92c46fde4989dc8b7cd04627e450e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8981c1945067b517a0cac1d4865c9cc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Perf.html#gaa8981c1945067b517a0cac1d4865c9cc">rt_perf_start</a> (rt_perf_t *perf)</td></tr>
<tr class="memdesc:gaa8981c1945067b517a0cac1d4865c9cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start monitoring configured events.  <a href="#gaa8981c1945067b517a0cac1d4865c9cc">More...</a><br /></td></tr>
<tr class="separator:gaa8981c1945067b517a0cac1d4865c9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dd4e97b0a1391ad18d0b7735704c4aa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Perf.html#ga5dd4e97b0a1391ad18d0b7735704c4aa">rt_perf_stop</a> (rt_perf_t *perf)</td></tr>
<tr class="memdesc:ga5dd4e97b0a1391ad18d0b7735704c4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop monitoring configured events.  <a href="#ga5dd4e97b0a1391ad18d0b7735704c4aa">More...</a><br /></td></tr>
<tr class="separator:ga5dd4e97b0a1391ad18d0b7735704c4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d27f54edb7c0493741e075ff3d17fb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Perf.html#ga2d27f54edb7c0493741e075ff3d17fb6">rt_perf_save</a> (rt_perf_t *perf)</td></tr>
<tr class="memdesc:ga2d27f54edb7c0493741e075ff3d17fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save performance counters values.  <a href="#ga2d27f54edb7c0493741e075ff3d17fb6">More...</a><br /></td></tr>
<tr class="separator:ga2d27f54edb7c0493741e075ff3d17fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23ec016ea3e198bac1084f53bdf0bab4"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Perf.html#ga23ec016ea3e198bac1084f53bdf0bab4">rt_perf_get</a> (rt_perf_t *perf, int id)</td></tr>
<tr class="memdesc:ga23ec016ea3e198bac1084f53bdf0bab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get performance counters values.  <a href="#ga23ec016ea3e198bac1084f53bdf0bab4">More...</a><br /></td></tr>
<tr class="separator:ga23ec016ea3e198bac1084f53bdf0bab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga095869ae740fecca53815e086a345f58"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Perf.html#ga095869ae740fecca53815e086a345f58">rt_perf_get_average</a> (rt_perf_t *perf, int id, int nb_cores)</td></tr>
<tr class="memdesc:ga095869ae740fecca53815e086a345f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get performance counters values average.  <a href="#ga095869ae740fecca53815e086a345f58">More...</a><br /></td></tr>
<tr class="separator:ga095869ae740fecca53815e086a345f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e13ee46f0ff647a027cb3208bfee003"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Perf.html#ga8e13ee46f0ff647a027cb3208bfee003">rt_perf_read</a> (int id)</td></tr>
<tr class="memdesc:ga8e13ee46f0ff647a027cb3208bfee003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a performance counter.  <a href="#ga8e13ee46f0ff647a027cb3208bfee003">More...</a><br /></td></tr>
<tr class="separator:ga8e13ee46f0ff647a027cb3208bfee003"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>This API gives access to the core performance counters. Each core has a few performance counters which can be configured to count one event out of several available. An event is a cycle, an instruction, a cache miss and so on. The number of counters limits the number of events which can be monitored at the same time and depends on the architecture and the platform.</p>
<p>In addition, this API uses a few other HW mechanisms useful for monitoring performance such as timers.</p>
<p>To use the API, a structure of type rt_perf_t must be allocated and passed to most of the calls. This structure contains the desired configuration and is used to save the values of the performance counters. It can be used by one core or several (if concurrent accesses are protected). The idea is that the hardware counters can be reset, started and stopped in order to get the event values for a specific period and this can then be cumulated to the performance structure. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gac08707c4e7d4bbab84241487aa11723b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac08707c4e7d4bbab84241487aa11723b">&#9670;&nbsp;</a></span>rt_perf_event_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Perf.html#gac08707c4e7d4bbab84241487aa11723b">rt_perf_event_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This can be used to describe which performance event to monitor (cycles, cache miss, etc). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac08707c4e7d4bbab84241487aa11723bae12a8ef21bc002344aef6e7e0b612d7f"></a>RT_PERF_CYCLES&#160;</td><td class="fielddoc"><p>Total number of cycles (also includes the cycles where the core is sleeping). Be careful that this event is using a timer shared within the cluster, so resetting, starting or stopping it on one core will impact other cores of the same cluster. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac08707c4e7d4bbab84241487aa11723ba8f1b2984ef3d204abb70499b56fe6c8a"></a>RT_PERF_ACTIVE_CYCLES&#160;</td><td class="fielddoc"><p>Counts the number of cycles the core was active (not sleeping). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac08707c4e7d4bbab84241487aa11723ba6a30b83932a11cee4e3d7c46c57cb633"></a>RT_PERF_INSTR&#160;</td><td class="fielddoc"><p>Counts the number of instructions executed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac08707c4e7d4bbab84241487aa11723ba7c684cd1d2575416b9c126e341ceae2c"></a>RT_PERF_LD_STALL&#160;</td><td class="fielddoc"><p>Number of load data hazards. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac08707c4e7d4bbab84241487aa11723ba9cc808514d59b6f736fcc7584f031491"></a>RT_PERF_JR_STALL&#160;</td><td class="fielddoc"><p>Number of jump register data hazards. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac08707c4e7d4bbab84241487aa11723bacdaecefc7186ec6755a3bd62af28c443"></a>RT_PERF_IMISS&#160;</td><td class="fielddoc"><p>Cycles waiting for instruction fetches, i.e. number of instructions wasted due to non-ideal caching. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac08707c4e7d4bbab84241487aa11723ba0623d6db0bae5a128a3056632a3ba8a1"></a>RT_PERF_WBRANCH&#160;</td><td class="fielddoc"><p>Number of wrong predicted branches </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac08707c4e7d4bbab84241487aa11723babe7fa6a557d5a569220415128127a98d"></a>RT_PERF_WBRANCH_CYC&#160;</td><td class="fielddoc"><p>Cycles wasted due to wrong predicted branches </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac08707c4e7d4bbab84241487aa11723ba4a9cb4c88848b01870dbe2adfaf30936"></a>RT_PERF_LD&#160;</td><td class="fielddoc"><p>Number of data memory loads executed. Misaligned accesses are counted twice. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac08707c4e7d4bbab84241487aa11723bafc8d2e26492decfaa3aa78362b930b90"></a>RT_PERF_ST&#160;</td><td class="fielddoc"><p>Number of data memory stores executed. Misaligned accesses are counted twice. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac08707c4e7d4bbab84241487aa11723ba67b088388a7f51fec97dab0c8f3d37e5"></a>RT_PERF_JUMP&#160;</td><td class="fielddoc"><p>Number of unconditional jumps (j, jal, jr, jalr). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac08707c4e7d4bbab84241487aa11723ba7784e3343524991c363617f0052258b7"></a>RT_PERF_BRANCH&#160;</td><td class="fielddoc"><p>Number of branches. Counts both taken and not taken branches. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac08707c4e7d4bbab84241487aa11723ba9e566ef65ce8f104d493a5924bc660af"></a>RT_PERF_DELAY_NOP&#160;</td><td class="fielddoc"><p>Number of empty delay slots, i.e. delay slots filled with a nop </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac08707c4e7d4bbab84241487aa11723ba78ba7315af37c9bad5a8e1ad3c825dc3"></a>RT_PERF_LD_EXT&#160;</td><td class="fielddoc"><p>Number of memory loads to EXT executed. Misaligned accesses are counted twice. Every non-TCDM access is considered external (cluster only). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac08707c4e7d4bbab84241487aa11723ba4e4806b88ddd3ca001c0796bd343a2a5"></a>RT_PERF_ST_EXT&#160;</td><td class="fielddoc"><p>Number of memory stores to EXT executed. Misaligned accesses are counted twice. Every non-TCDM access is considered external (cluster only). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac08707c4e7d4bbab84241487aa11723ba234404fb9630bcf29983df2e81f63032"></a>RT_PERF_LD_EXT_CYC&#160;</td><td class="fielddoc"><p>Cycles used for memory loads to EXT. Every non-TCDM access is considered external (cluster only). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac08707c4e7d4bbab84241487aa11723ba41ee2b3c0d1c7fd2ea29cc08a8e76bad"></a>RT_PERF_ST_EXT_CYC&#160;</td><td class="fielddoc"><p>Cycles used for memory stores to EXT. Every non-TCDM access is considered external (cluster only). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac08707c4e7d4bbab84241487aa11723baa988e0e342ee8f128fc3ca09d83bc140"></a>RT_PERF_TCDM_CONT&#160;</td><td class="fielddoc"><p>Cycles wasted due to TCDM/log-interconnect contention (cluster only). </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gace8fce89c8fd3a8fd96660ad4d7d1853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace8fce89c8fd3a8fd96660ad4d7d1853">&#9670;&nbsp;</a></span>rt_perf_conf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_perf_conf </td>
          <td>(</td>
          <td class="paramtype">rt_perf_t *&#160;</td>
          <td class="paramname"><em>perf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The set of events which can be activated at the same time depends on the architecture and the platform. On real chips (rather than with the simulator), there is always only one counter. It is advisable to always use only one to be compatible with simulator and chip.</p>
<p>At least RT_PERF_CYCLES and another event can be monitored at the same time as the first one is using the timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perf</td><td>A pointer to the performance structure. </td></tr>
    <tr><td class="paramname">events</td><td>A mask containing the events to activate. This is a bitfield, so events identifier must be used like 1 &lt;&lt; RT_PERF_CYCLES. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga23ec016ea3e198bac1084f53bdf0bab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23ec016ea3e198bac1084f53bdf0bab4">&#9670;&nbsp;</a></span>rt_perf_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int rt_perf_get </td>
          <td>(</td>
          <td class="paramtype">rt_perf_t *&#160;</td>
          <td class="paramname"><em>perf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This returns the saved values, thus rt_perf_save must be called before at least once.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perf</td><td>A pointer to the performance structure. </td></tr>
    <tr><td class="paramname">id</td><td>The performance event identifier to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The performance counter value. </dd></dl>

</div>
</div>
<a id="ga095869ae740fecca53815e086a345f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga095869ae740fecca53815e086a345f58">&#9670;&nbsp;</a></span>rt_perf_get_average()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int rt_perf_get_average </td>
          <td>(</td>
          <td class="paramtype">rt_perf_t *&#160;</td>
          <td class="paramname"><em>perf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_cores</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This returns the saved values, thus rt_perf_save must be called before at least once. This will compute an average of the specified event between all the specified performance structures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perf</td><td>A pointer to an array of performance structures. </td></tr>
    <tr><td class="paramname">id</td><td>The performance event identifier to get. </td></tr>
    <tr><td class="paramname">nb_cores</td><td>The number of performance structures on which the average must be done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The performance counter value. </dd></dl>

</div>
</div>
<a id="gaf013daf2ab420189ad6ab19fa9cd73f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf013daf2ab420189ad6ab19fa9cd73f0">&#9670;&nbsp;</a></span>rt_perf_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_perf_init </td>
          <td>(</td>
          <td class="paramtype">rt_perf_t *&#160;</td>
          <td class="paramname"><em>perf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function initializes to 0 the value of all performance counters in the specified structure. Note that this does not initialize the value of the hardware counters which can be done with rt_perf_reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perf</td><td>A pointer to the performance structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8e13ee46f0ff647a027cb3208bfee003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e13ee46f0ff647a027cb3208bfee003">&#9670;&nbsp;</a></span>rt_perf_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int rt_perf_read </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This does a direct read to the specified performance counter. Calling this functions is useful for getting the performance counter with very low overhead (just few instructions).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The performance event identifier to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The performance counter value. </dd></dl>

</div>
</div>
<a id="gae92c46fde4989dc8b7cd04627e450e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae92c46fde4989dc8b7cd04627e450e58">&#9670;&nbsp;</a></span>rt_perf_reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rt_perf_reset </td>
          <td>(</td>
          <td class="paramtype">rt_perf_t *&#160;</td>
          <td class="paramname"><em>perf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All hardware performance counters are set to 0. Note that this does not modify the value of the counters in the specified structure, this must be done by calling rt_perf_init.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perf</td><td>A pointer to the performance structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2d27f54edb7c0493741e075ff3d17fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d27f54edb7c0493741e075ff3d17fb6">&#9670;&nbsp;</a></span>rt_perf_save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_perf_save </td>
          <td>(</td>
          <td class="paramtype">rt_perf_t *&#160;</td>
          <td class="paramname"><em>perf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This loads the performance counters values and adds them inside the performance structure. This is useful when reconfiguring the events in order to aggregate all the events together into the performance structure. Note that the values are cumulated inside the performance structure so that several portion of code can be cumulated together. Don't forget to reset the HW counters with rt_perf_reset or the the counters in the structure with rt_perf_init if you don't want to cumulate the values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perf</td><td>A pointer to the performance structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa8981c1945067b517a0cac1d4865c9cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8981c1945067b517a0cac1d4865c9cc">&#9670;&nbsp;</a></span>rt_perf_start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rt_perf_start </td>
          <td>(</td>
          <td class="paramtype">rt_perf_t *&#160;</td>
          <td class="paramname"><em>perf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is useful for finely controlling the point where performance events start being monitored. The counter retains its value between stop and start so it is possible to easily sum events for several portions of code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perf</td><td>A pointer to the performance structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5dd4e97b0a1391ad18d0b7735704c4aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dd4e97b0a1391ad18d0b7735704c4aa">&#9670;&nbsp;</a></span>rt_perf_stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rt_perf_stop </td>
          <td>(</td>
          <td class="paramtype">rt_perf_t *&#160;</td>
          <td class="paramname"><em>perf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perf</td><td>A pointer to the performance structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
	<!--
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 
	-->
	</li>
  </ul>
</div>
</body>
</html>
