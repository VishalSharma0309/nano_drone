<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Event scheduler</title>
<title>Runtime: Event scheduler</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pulp.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="printComponentTabs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 46px;">
  <td id="projectlogo"><img alt="Logo" src="Pulp_logo_inline.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Runtime
   &#160;<span id="projectnumber">Version 1.0</span>
   </div>
   <div id="projectbrief">PULP Kernel Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
    <ul class="tablist">
      <script type="text/javascript">
		<!--
		writeComponentTabs.call(this);
		//-->
      </script>
	  </ul>
</div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__Event.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Event scheduler<div class="ingroups"><a class="el" href="group__groupKernel.html">Kernel</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga85c9262feb7f2bd2048aa6d4c876f506"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Event.html#ga85c9262feb7f2bd2048aa6d4c876f506">rt_event_sched_init</a> (<a class="el" href="structrt__event__sched__t.html">rt_event_sched_t</a> *sched)</td></tr>
<tr class="memdesc:ga85c9262feb7f2bd2048aa6d4c876f506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an event scheduler.  <a href="#ga85c9262feb7f2bd2048aa6d4c876f506">More...</a><br /></td></tr>
<tr class="separator:ga85c9262feb7f2bd2048aa6d4c876f506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e355251700ab096c5eed1caeba817f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Event.html#ga5e355251700ab096c5eed1caeba817f3">rt_event_alloc</a> (<a class="el" href="structrt__event__sched__t.html">rt_event_sched_t</a> *sched, int nb_events)</td></tr>
<tr class="memdesc:ga5e355251700ab096c5eed1caeba817f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate new events.  <a href="#ga5e355251700ab096c5eed1caeba817f3">More...</a><br /></td></tr>
<tr class="separator:ga5e355251700ab096c5eed1caeba817f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59c688d0f222bad0032b8ecfed3d2eb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Event.html#ga59c688d0f222bad0032b8ecfed3d2eb7">rt_event_free</a> (<a class="el" href="structrt__event__sched__t.html">rt_event_sched_t</a> *sched, int nb_events)</td></tr>
<tr class="memdesc:ga59c688d0f222bad0032b8ecfed3d2eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free events.  <a href="#ga59c688d0f222bad0032b8ecfed3d2eb7">More...</a><br /></td></tr>
<tr class="separator:ga59c688d0f222bad0032b8ecfed3d2eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56e7263ee9e0721e86cb52fefd3dbbde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Event.html#ga56e7263ee9e0721e86cb52fefd3dbbde">rt_event_get</a> (<a class="el" href="structrt__event__sched__t.html">rt_event_sched_t</a> *sched, void(*callback)(void *), void *arg)</td></tr>
<tr class="memdesc:ga56e7263ee9e0721e86cb52fefd3dbbde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve an event and set its callback and argument.  <a href="#ga56e7263ee9e0721e86cb52fefd3dbbde">More...</a><br /></td></tr>
<tr class="separator:ga56e7263ee9e0721e86cb52fefd3dbbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga246b22bb53f501797250e44d39595399"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Event.html#ga246b22bb53f501797250e44d39595399">rt_event_get_permanent</a> (<a class="el" href="structrt__event__sched__t.html">rt_event_sched_t</a> *sched, void(*callback)(void *), void *arg)</td></tr>
<tr class="memdesc:ga246b22bb53f501797250e44d39595399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve a permanent event and set its callback and argument.  <a href="#ga246b22bb53f501797250e44d39595399">More...</a><br /></td></tr>
<tr class="separator:ga246b22bb53f501797250e44d39595399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0c03de180c89e4ce4d8937a08e5fab"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Event.html#ga5f0c03de180c89e4ce4d8937a08e5fab">rt_event_irq_get</a> (void(*callback)(void *), void *arg)</td></tr>
<tr class="memdesc:ga5f0c03de180c89e4ce4d8937a08e5fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve an IRQ event and set its callback and argument.  <a href="#ga5f0c03de180c89e4ce4d8937a08e5fab">More...</a><br /></td></tr>
<tr class="separator:ga5f0c03de180c89e4ce4d8937a08e5fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga988bdd5a55434743664388c7315b4f03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Event.html#ga988bdd5a55434743664388c7315b4f03">rt_event_get_blocking</a> (<a class="el" href="structrt__event__sched__t.html">rt_event_sched_t</a> *sched)</td></tr>
<tr class="memdesc:ga988bdd5a55434743664388c7315b4f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve an event for blocking wait.  <a href="#ga988bdd5a55434743664388c7315b4f03">More...</a><br /></td></tr>
<tr class="separator:ga988bdd5a55434743664388c7315b4f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06feaaf8334347ef8087f4588aa7edb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Event.html#ga06feaaf8334347ef8087f4588aa7edb3">rt_event_push</a> (<a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *event)</td></tr>
<tr class="memdesc:ga06feaaf8334347ef8087f4588aa7edb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an event to a scheduler.  <a href="#ga06feaaf8334347ef8087f4588aa7edb3">More...</a><br /></td></tr>
<tr class="separator:ga06feaaf8334347ef8087f4588aa7edb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fe46ee796b823aa015d1ced8d08e274"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Event.html#ga7fe46ee796b823aa015d1ced8d08e274">rt_event_push_callback</a> (<a class="el" href="structrt__event__sched__t.html">rt_event_sched_t</a> *sched, void(*callback)(void *), void *arg)</td></tr>
<tr class="memdesc:ga7fe46ee796b823aa015d1ced8d08e274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a callback to a scheduler.  <a href="#ga7fe46ee796b823aa015d1ced8d08e274">More...</a><br /></td></tr>
<tr class="separator:ga7fe46ee796b823aa015d1ced8d08e274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b2d85a086a5d7b7a1b6a5226d965994"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Event.html#ga4b2d85a086a5d7b7a1b6a5226d965994">rt_event_execute</a> (<a class="el" href="structrt__event__sched__t.html">rt_event_sched_t</a> *sched, int wait)</td></tr>
<tr class="memdesc:ga4b2d85a086a5d7b7a1b6a5226d965994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute all pending events.  <a href="#ga4b2d85a086a5d7b7a1b6a5226d965994">More...</a><br /></td></tr>
<tr class="separator:ga4b2d85a086a5d7b7a1b6a5226d965994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03151afd885a8738e9a793f7d0cdb0bf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Event.html#ga03151afd885a8738e9a793f7d0cdb0bf">rt_event_yield</a> (<a class="el" href="structrt__event__sched__t.html">rt_event_sched_t</a> *sched)</td></tr>
<tr class="memdesc:ga03151afd885a8738e9a793f7d0cdb0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute pending events.  <a href="#ga03151afd885a8738e9a793f7d0cdb0bf">More...</a><br /></td></tr>
<tr class="separator:ga03151afd885a8738e9a793f7d0cdb0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c7808c990317ef246848e486f2a79bd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structrt__event__sched__t.html">rt_event_sched_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Event.html#ga8c7808c990317ef246848e486f2a79bd">rt_event_internal_sched</a> ()</td></tr>
<tr class="memdesc:ga8c7808c990317ef246848e486f2a79bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the internal runtime event scheduler.  <a href="#ga8c7808c990317ef246848e486f2a79bd">More...</a><br /></td></tr>
<tr class="separator:ga8c7808c990317ef246848e486f2a79bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de6b7e05ce2137584b436ce6f4f32f7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Event.html#ga2de6b7e05ce2137584b436ce6f4f32f7">rt_event_thread_sched</a> (rt_thread_t *thread, <a class="el" href="structrt__event__sched__t.html">rt_event_sched_t</a> *sched)</td></tr>
<tr class="memdesc:ga2de6b7e05ce2137584b436ce6f4f32f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a thread event scheduler.  <a href="#ga2de6b7e05ce2137584b436ce6f4f32f7">More...</a><br /></td></tr>
<tr class="separator:ga2de6b7e05ce2137584b436ce6f4f32f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac77fc419caea78db6df910ca502a2705"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Event.html#gac77fc419caea78db6df910ca502a2705">rt_event_wait</a> (<a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *event)</td></tr>
<tr class="memdesc:gac77fc419caea78db6df910ca502a2705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block the execution until the event has been triggered.  <a href="#gac77fc419caea78db6df910ca502a2705">More...</a><br /></td></tr>
<tr class="separator:gac77fc419caea78db6df910ca502a2705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae74c7c4794702caceea210b910add622"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Event.html#gae74c7c4794702caceea210b910add622">rt_event_push_delayed</a> (<a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *event, int time_us)</td></tr>
<tr class="memdesc:gae74c7c4794702caceea210b910add622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an event to a scheduler after the specified amount of time.  <a href="#gae74c7c4794702caceea210b910add622">More...</a><br /></td></tr>
<tr class="separator:gae74c7c4794702caceea210b910add622"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>The asynchronous interactions between the fabric controller, the cluster and the peripherals are managed with events on the fabric controller side.</p>
<p>An event is a function callback which can be pushed to an event scheduler, for a deferred execution. All events in the same scheduler are executed in-order, in a FIFO manner.</p>
<p>In order to manage several levels of event priorities, there may be several event schedulers at the same time. The application is entered with one event scheduler already created in the runtime, which is the one which can be used as the default scheduler. However the application can then create multiple event schedulers in order to build a more complex multi-priority scenario.</p>
<p>Event schedulers are only executed when specific actions are executed by the application. They can be either invoked explicitly by calling rt_event_execute or implicitly when for example no thread is active and the application is blocked waiting for something.</p>
<p>The pool of events which can be pushed to schedulers must be explicitly managed by the application. There is by default no event allocated. They must be first allocated before they can be pushed to schedulers. This allows the application to decide the optimal number of events that it needs depending on the various actions which can occur.</p>
<p>When a scheduler is invoked, it executes all its pending events, unless the current thread is preempted to schedule another thread. To execute an event, it removes it from the queue and executes the associated callback with its argument, until the callback returns. This scheduler can not execute any other event until the callback has returned.</p>
<p>Each thread is assigned an event scheduler. By default, when a thread is created, it is assigned the internal event scheduler. Another scheduler can then be assigned by the application. This scheduler is the one implicitly invoked when the thread is calling a blocking operation such as waiting for an event. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5e355251700ab096c5eed1caeba817f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e355251700ab096c5eed1caeba817f3">&#9670;&nbsp;</a></span>rt_event_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_event_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__event__sched__t.html">rt_event_sched_t</a> *&#160;</td>
          <td class="paramname"><em>sched</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates the specified number of events and put them in the free list. These events can then be reserved through other functions and pushed to the scheduler. Note that this function can be called several times in order to add more events to the scheduler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sched</td><td>The scheduler for which the events are intended to be used. If NULL the default scheduler for the current thread is used. </td></tr>
    <tr><td class="paramname">nb_events</td><td>The number of events to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfull, 1 otherwise. </dd></dl>

</div>
</div>
<a id="ga4b2d85a086a5d7b7a1b6a5226d965994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b2d85a086a5d7b7a1b6a5226d965994">&#9670;&nbsp;</a></span>rt_event_execute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rt_event_execute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__event__sched__t.html">rt_event_sched_t</a> *&#160;</td>
          <td class="paramname"><em>sched</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will invoke the specified scheduler and execute all its pending events. If no event is ready when the scheduler is invoked and the wait argument is 1, the calling thread is blocked until something happens, otherwise the function just returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sched</td><td>The scheduler on which the events are executed. </td></tr>
    <tr><td class="paramname">wait</td><td>If 1, this will block the calling thread until something happens. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga59c688d0f222bad0032b8ecfed3d2eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59c688d0f222bad0032b8ecfed3d2eb7">&#9670;&nbsp;</a></span>rt_event_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_event_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__event__sched__t.html">rt_event_sched_t</a> *&#160;</td>
          <td class="paramname"><em>sched</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the specified number of events from the free list and frees them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sched</td><td>The scheduler for which the events must be freed </td></tr>
    <tr><td class="paramname">nb_events</td><td>The number of events to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga56e7263ee9e0721e86cb52fefd3dbbde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56e7263ee9e0721e86cb52fefd3dbbde">&#9670;&nbsp;</a></span>rt_event_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a>* rt_event_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__event__sched__t.html">rt_event_sched_t</a> *&#160;</td>
          <td class="paramname"><em>sched</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This gets an event from the free list and initializes it with the specified callback. The event is then ready to be pushed to the scheduler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sched</td><td>The scheduler for which to get the event for. </td></tr>
    <tr><td class="paramname">callback</td><td>The function which will be called when the event is executed. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument of the function callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The assigned event if there was at least one available, or NULL if not. </dd></dl>

</div>
</div>
<a id="ga988bdd5a55434743664388c7315b4f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga988bdd5a55434743664388c7315b4f03">&#9670;&nbsp;</a></span>rt_event_get_blocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a>* rt_event_get_blocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__event__sched__t.html">rt_event_sched_t</a> *&#160;</td>
          <td class="paramname"><em>sched</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This gets an event from the free list, which can then be used for a blocking wait using rt_event_wait.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sched</td><td>The scheduler for which to get the event for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The assigned event if there was at least one available, or NULL if not. </dd></dl>

</div>
</div>
<a id="ga246b22bb53f501797250e44d39595399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga246b22bb53f501797250e44d39595399">&#9670;&nbsp;</a></span>rt_event_get_permanent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a>* rt_event_get_permanent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__event__sched__t.html">rt_event_sched_t</a> *&#160;</td>
          <td class="paramname"><em>sched</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This gets an event from the free list and initializes it with the specified callback. The event is then ready to be pushed to the scheduler. Compared to normal events, this one is never released and can be reused without being re-allocated, for example for regular actions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sched</td><td>The scheduler for which to get the event for. </td></tr>
    <tr><td class="paramname">callback</td><td>The function which will be called when the event is executed. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument of the function callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The assigned event if there was at least one available, or NULL if not. </dd></dl>

</div>
</div>
<a id="ga8c7808c990317ef246848e486f2a79bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c7808c990317ef246848e486f2a79bd">&#9670;&nbsp;</a></span>rt_event_internal_sched()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structrt__event__sched__t.html">rt_event_sched_t</a>* rt_event_internal_sched </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This returns the runtime event scheduler which is created at boot time and which can be used as a default scheduler.</p>
<dl class="section return"><dt>Returns</dt><dd>The runtime scheduler. </dd></dl>

</div>
</div>
<a id="ga5f0c03de180c89e4ce4d8937a08e5fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f0c03de180c89e4ce4d8937a08e5fab">&#9670;&nbsp;</a></span>rt_event_irq_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a>* rt_event_irq_get </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This gets an IRQ event from the free list and initializes it with the specified callback. Contrary to classic events, IRQ events are not meant to be pushed to a scheduler, they should instead be used in specific cases where an interrupt handler should execute directly the callback instead of enqueueing the event to a scheduler. These events should be used in very specific cases where it is explicitely mentionned they can be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The function which will be called when the event is executed. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument of the function callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The assigned event if there was at least one available, or NULL if not. </dd></dl>

</div>
</div>
<a id="ga06feaaf8334347ef8087f4588aa7edb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06feaaf8334347ef8087f4588aa7edb3">&#9670;&nbsp;</a></span>rt_event_push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_event_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This pushes the event to its scheduler, and makes it ready to be executed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The event to be pushed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7fe46ee796b823aa015d1ced8d08e274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fe46ee796b823aa015d1ced8d08e274">&#9670;&nbsp;</a></span>rt_event_push_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_event_push_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__event__sched__t.html">rt_event_sched_t</a> *&#160;</td>
          <td class="paramname"><em>sched</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This pushes a function callback to the specified scheduler. An event is reserved from the scheduler, initialized with the callback, and pushed to the scheduler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sched</td><td>The scheduler to push the callback on. </td></tr>
    <tr><td class="paramname">callback</td><td>The function which will be called when the event is executed. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument of the function callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, 1 otherwise. </dd></dl>

</div>
</div>
<a id="gae74c7c4794702caceea210b910add622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae74c7c4794702caceea210b910add622">&#9670;&nbsp;</a></span>rt_event_push_delayed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_event_push_delayed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>time_us</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This first waits that the specified amount of time has passed and then pushes the event to its scheduler, and makes it ready to be executed. The time is specified in microseconds and is a minimum amount of time. The actual time may be bigger due to timer resolution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The event to be pushed. </td></tr>
    <tr><td class="paramname">time_us</td><td>The time in microseconds after which the event is pushed to the scheduler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga85c9262feb7f2bd2048aa6d4c876f506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85c9262feb7f2bd2048aa6d4c876f506">&#9670;&nbsp;</a></span>rt_event_sched_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_event_sched_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__event__sched__t.html">rt_event_sched_t</a> *&#160;</td>
          <td class="paramname"><em>sched</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This initialize the scheduler and makes it usable. As soon as this function is executed, events can be enqueued to the scheduler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sched</td><td>Pointer to the scheduler structure. This structure must be allocated by the caller and must be kept allocated until the scheduler is not used anymore. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2de6b7e05ce2137584b436ce6f4f32f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2de6b7e05ce2137584b436ce6f4f32f7">&#9670;&nbsp;</a></span>rt_event_thread_sched()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rt_event_thread_sched </td>
          <td>(</td>
          <td class="paramtype">rt_thread_t *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrt__event__sched__t.html">rt_event_sched_t</a> *&#160;</td>
          <td class="paramname"><em>sched</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This sets the event scheduler of the thread, i.e. the event scheduler which is implicitly invoked when the thread is blocked waiting for something. This means only events from this scheduler will be able to wake-up this thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread for which the event scheduler must be set. </td></tr>
    <tr><td class="paramname">sched</td><td>The new scheduler of the thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac77fc419caea78db6df910ca502a2705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac77fc419caea78db6df910ca502a2705">&#9670;&nbsp;</a></span>rt_event_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_event_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gap8__emul_8h.html#a8296d4f358c4e2b389cc71656fe86353">rt_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The event must be a blocking one, allocated through rt_event_get_blocking.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The event to wait for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga03151afd885a8738e9a793f7d0cdb0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03151afd885a8738e9a793f7d0cdb0bf">&#9670;&nbsp;</a></span>rt_event_yield()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rt_event_yield </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrt__event__sched__t.html">rt_event_sched_t</a> *&#160;</td>
          <td class="paramname"><em>sched</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will invoke the specified scheduler and execute all its pending events. If no event is ready when the scheduler is invoked, the calling thread is blocked until something appens.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sched</td><td>The scheduler on which the events are executed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
	<!--
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 
	-->
	</li>
  </ul>
</div>
</body>
</html>
