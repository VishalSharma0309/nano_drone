SDK makefiles
=============

Introduction
------------

Although applications can be compiled and run on Pulp platform by hands, by directly calling
the tool chain with the appropriate flags, and the platform runner, some generic makefiles are provided in the SDK to simplify this task.

To use these makefiles, the following line must be included in the application makefile, which will give access to the SDK targets, flags and options documented afterwards: ::
  include $(PULP_SDK_HOME)/install/rules/pulp_rt.mk

Getting help
------------


Although the main available targets, flags and options are documented in the following sections through examples, some inlined documentation can be obtained from the command line.

All the available make targets and options can be obtained by executing this command from a makefile which is including the SDK makefile: ::

  make help

More documentation can be obtained about the flags with this command: ::

  make help_flags

About the available configuration options: ::

  make help_config

And about the available makefile options: ::

  make help_opt

Application makefile sample
---------------------------

Here is a minimal makefile example, which allows compiling and running a simple application: ::

  PULP_APP = test
  PULP_APP_SRCS = test.c
  PULP_CFLAGS = -O3 -g  
  include $(PULP_SDK_HOME)/install/rules/pulp_rt.mk

The application must be given a name with *PULP_APP*. This is used for the application binary name but can also be used to specify application-specific options.

The source files are specified with the *PULP_APP_SRCS* flag. This will trigger the compilation of the specified file when the appropriate target is executed.

The optional flag *PULP_CFLAGS* flag is used to specify a few compilation options, in the example above the optimization level.

Application compilation
-----------------------

Once the flags described in the previous section are put into the application makefile, the following command can be used to compile the application (from the folder containing the makefile): ::

  $ make all

This will compile all the source files specified in *PULP_APP_SRCS* and do the final link.

If the makefile is modified, it may be necessary to clean and recompile the application with the following command: ::

  $ make clean all

In some cases where the target configuration is changed or the build folder is moved, it may be
needed to remove the build folder by hands.



Application run
---------------

Once the application has been compiled, it can be run with the following command: ::

  $ make run

This will run the application on the current platform which is by default the virtual platform.



Global configuration
--------------------

The system configuration for which the application is compiled and run is stored in the environnement variable *PULP_CURRENT_CONFIG* and is set automatically when the proper target is configured in the SDK setup procedure and can be displayed with this command: ::

  $ echo $PULP_CURRENT_CONFIG

It is then possible to customize this configuration in order to apply it to all applications. For that, just define this environnement variable: ::

  $ export PULP_CURRENT_CONFIG_ARGS=gvsoc/trace=iss

With this configuration example, all applications will have virtual platform traces active.

One important point: anytime the global configuration is modified, the application must be reconfigured in order to take it into account. This can be done with this command (see section *Reconfiguration* below for more details): ::

  $ make conf

In order to keep the previous configuration and just extend it, just put back the content of *PULP_CURRENT_CONFIG* and extend it.




Application reconfiguration
---------------

The configuration used for compiling and running the application is selected when the SDK is initialized, depending on the script which is sourced.

It is then possible to customize this configuration in order to give platform options or to slightly change the architecture and so on. For that the makefile option *CONFIG_OPT* can be used combined with the *conf* target, like in the following command: ::

  $ make conf CONFIG_OPT="gvsoc/trace=iss"

After the configuration has been modified with such a command, the application must be recompiled in order to take it into account: ::

  $ make clean all run

It is important that the *conf* target is executed as a separate make command, and that the application is recompiled after that with another make command, otherwise the new configuration will not be taken into account.



Build folder
------------

So that different configurations can be used at the same time, each global configuration is having its own build directory, which is a subdirectory of the global build directory.

The build folder is used for storing temporary files, like objects files, and the application is launched from the build folder so that all files generated by the platform during execution goes there.

The global directory is defined in the makefile flag *BUILD_DIR* and can be redefined, either inside the makefile, the command file or as an evironment variable, like in this example: ::

  $ make clean all run BUILD_DIR=my_build

In this case, this will place all configuration subdirectories in the specified one.

Each configuration subdirectory is named with the configuration name, which is either the short name given with *@*, or the raw configuration name. A few special characters are replaced so that it does not disturb the makefiles (e.g. each *=* is turned into *.*). For example, by default, the configuration named *template=wolfe* will have *build/template.wolfe* as build folder while *wolfe@template=wolfe* will have *build/wolfe*.

The configuration build folder can also be overloaded as for the global build folder: ::

  $ make clean all run CONFIG_BUILD_DIR=my_build

Note that both *BUILD_DIR* and *CONFIG_BUILD_DIR* can be used from the makefile, for example to put some stimuli files into the build folder.

In case several tests from the same test folder can be launched in parallel, it can be useful to get one different build folder per test. In this case, BUILD_DIR_EXT can be defined in order to extend the build folder name. The full build folder is then $CONFIG_BUILD_DIR$BUILD_DIR_EXT. This can be specified for example on the command line like this: ::

  $ make clean all run BUILD_DIR_EXT=_test0